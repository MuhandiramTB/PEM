export declare const ApplicationGroupType: {
    /**
     * Application group is Remote and can launch individual applications without a Desktop.
     */
    readonly RemoteApp: "RemoteApp";
    /**
     * Application Group delivers a full expected Desktop experience
     */
    readonly Desktop: "Desktop";
};
/**
 * Resource Type of ApplicationGroup.
 */
export type ApplicationGroupType = (typeof ApplicationGroupType)[keyof typeof ApplicationGroupType];
export declare const CommandLineSetting: {
    /**
     * Cannot be launched with command line arguments.
     */
    readonly DoNotAllow: "DoNotAllow";
    /**
     * Can optionally be launched with command line arguments.
     */
    readonly Allow: "Allow";
    /**
     * Required to be launched with command line arguments.
     */
    readonly Require: "Require";
};
/**
 * Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
 */
export type CommandLineSetting = (typeof CommandLineSetting)[keyof typeof CommandLineSetting];
export declare const DayOfWeek: {
    readonly Monday: "Monday";
    readonly Tuesday: "Tuesday";
    readonly Wednesday: "Wednesday";
    readonly Thursday: "Thursday";
    readonly Friday: "Friday";
    readonly Saturday: "Saturday";
    readonly Sunday: "Sunday";
};
/**
 * Day of the week. Modeled as string
 */
export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek];
export declare const DirectUDP: {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    readonly Default: "Default";
    /**
     * UDP will attempt this connection type when making connections.
     */
    readonly Enabled: "Enabled";
    /**
     * UDP will not attempt this connection type when making connections
     */
    readonly Disabled: "Disabled";
};
/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type DirectUDP = (typeof DirectUDP)[keyof typeof DirectUDP];
export declare const FailHealthCheckOnStagingFailure: {
    /**
     * Health Check will report unhealthy
     */
    readonly Unhealthy: "Unhealthy";
    /**
     * Health Check will report NeedsAssistance
     */
    readonly NeedsAssistance: "NeedsAssistance";
    /**
     * Health Check will not report failure
     */
    readonly DoNotFail: "DoNotFail";
};
/**
 * Parameter indicating how the health check should behave if this package fails staging
 */
export type FailHealthCheckOnStagingFailure = (typeof FailHealthCheckOnStagingFailure)[keyof typeof FailHealthCheckOnStagingFailure];
export declare const HostPoolType: {
    /**
     * Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
     */
    readonly Personal: "Personal";
    /**
     * Users get a new (random) SessionHost every time it connects to the HostPool.
     */
    readonly Pooled: "Pooled";
    /**
     * Users assign their own machines, load balancing logic remains the same as Personal. PersonalDesktopAssignmentType must be Direct.
     */
    readonly BYODesktop: "BYODesktop";
};
/**
 * HostPool type for desktop.
 */
export type HostPoolType = (typeof HostPoolType)[keyof typeof HostPoolType];
export declare const HostpoolPublicNetworkAccess: {
    /**
     * Allows this resource to be accessed from the public network
     */
    readonly Enabled: "Enabled";
    /**
     * Prevents this resource from being accessed from the public network
     */
    readonly Disabled: "Disabled";
    /**
     * Allows SessionHosts to be accessed from the public network
     */
    readonly EnabledForSessionHostsOnly: "EnabledForSessionHostsOnly";
    /**
     * Allows Clients to be accessed from the public network
     */
    readonly EnabledForClientsOnly: "EnabledForClientsOnly";
};
/**
 * Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
 */
export type HostpoolPublicNetworkAccess = (typeof HostpoolPublicNetworkAccess)[keyof typeof HostpoolPublicNetworkAccess];
export declare const LoadBalancerType: {
    /**
     * Uses BreadthFirst algorithm for load balancing.
     */
    readonly BreadthFirst: "BreadthFirst";
    /**
     * Uses DepthFirst algorithm for load balancing.
     */
    readonly DepthFirst: "DepthFirst";
    /**
     * Maintains persistent connections.
     */
    readonly Persistent: "Persistent";
    /**
     * Maintains multiple persistents connections.
     */
    readonly MultiplePersistent: "MultiplePersistent";
};
/**
 * The type of the load balancer.
 */
export type LoadBalancerType = (typeof LoadBalancerType)[keyof typeof LoadBalancerType];
export declare const ManagedPrivateUDP: {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    readonly Default: "Default";
    /**
     * UDP will attempt this connection type when making connections.
     */
    readonly Enabled: "Enabled";
    /**
     * UDP will not attempt this connection type when making connections
     */
    readonly Disabled: "Disabled";
};
/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type ManagedPrivateUDP = (typeof ManagedPrivateUDP)[keyof typeof ManagedPrivateUDP];
export declare const ManagedServiceIdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned,UserAssigned";
};
/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const ManagementType: {
    /**
     * Automated management of the hostpool
     */
    readonly Automated: "Automated";
    /**
     * Standard management of the hostpool
     */
    readonly Standard: "Standard";
};
/**
 * The type of management for this hostpool, Automated or Standard. The default value is Automated.
 */
export type ManagementType = (typeof ManagementType)[keyof typeof ManagementType];
export declare const PackageTimestamped: {
    /**
     * Package is timestamped
     */
    readonly Timestamped: "Timestamped";
    /**
     * Package is not timestamped, use certificate expiry date
     */
    readonly NotTimestamped: "NotTimestamped";
};
/**
 * Is package timestamped so it can ignore the certificate expiry date
 */
export type PackageTimestamped = (typeof PackageTimestamped)[keyof typeof PackageTimestamped];
export declare const PersonalDesktopAssignmentType: {
    /**
     * Automatically assigns an available personal desktop to the user.
     */
    readonly Automatic: "Automatic";
    /**
     * Manually assigns a specific personal desktop to the user.
     */
    readonly Direct: "Direct";
};
/**
 * PersonalDesktopAssignment type for HostPool.
 */
export type PersonalDesktopAssignmentType = (typeof PersonalDesktopAssignmentType)[keyof typeof PersonalDesktopAssignmentType];
export declare const PreferredAppGroupType: {
    /**
     * Internal Use Only
     */
    readonly None: "None";
    /**
     * Use Desktop Application Group
     */
    readonly Desktop: "Desktop";
    /**
     * Use RailApplications (RemoteApp)
     */
    readonly RailApplications: "RailApplications";
};
/**
 * The type of preferred application group type, default to Desktop Application Group
 */
export type PreferredAppGroupType = (typeof PreferredAppGroupType)[keyof typeof PreferredAppGroupType];
export declare const PrivateEndpointServiceConnectionStatus: {
    /**
     * Connection is Pending
     */
    readonly Pending: "Pending";
    /**
     * Connection was Approved
     */
    readonly Approved: "Approved";
    /**
     * Connection was rejected
     */
    readonly Rejected: "Rejected";
};
/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];
export declare const PublicNetworkAccess: {
    /**
     * This resource is accessible from the public network.
     */
    readonly Enabled: "Enabled";
    /**
     * This resource is not accessible from the public network.
     */
    readonly Disabled: "Disabled";
};
/**
 * Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];
export declare const PublicUDP: {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    readonly Default: "Default";
    /**
     * UDP will attempt this connection type when making connections.
     */
    readonly Enabled: "Enabled";
    /**
     * UDP will not attempt this connection type when making connections
     */
    readonly Disabled: "Disabled";
};
/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type PublicUDP = (typeof PublicUDP)[keyof typeof PublicUDP];
export declare const RegistrationTokenOperation: {
    /**
     * Delete operation
     */
    readonly Delete: "Delete";
    /**
     * No Operation
     */
    readonly None: "None";
    /**
     * Update Operation
     */
    readonly Update: "Update";
};
/**
 * The type of resetting the token.
 */
export type RegistrationTokenOperation = (typeof RegistrationTokenOperation)[keyof typeof RegistrationTokenOperation];
export declare const RelayUDP: {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    readonly Default: "Default";
    /**
     * UDP will attempt this connection type when making connections.
     */
    readonly Enabled: "Enabled";
    /**
     * UDP will not attempt this connection type when making connections
     */
    readonly Disabled: "Disabled";
};
/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type RelayUDP = (typeof RelayUDP)[keyof typeof RelayUDP];
export declare const RemoteApplicationType: {
    /**
     * Built-in applications
     */
    readonly InBuilt: "InBuilt";
    /**
     * Imported MSIX application packages
     */
    readonly MsixApplication: "MsixApplication";
};
/**
 * Resource Type of Application.
 */
export type RemoteApplicationType = (typeof RemoteApplicationType)[keyof typeof RemoteApplicationType];
export declare const SSOSecretType: {
    /**
     * The SSO Secret is a Shared Key.
     */
    readonly SharedKey: "SharedKey";
    /**
     * The SSO Secret is a Certificate.
     */
    readonly Certificate: "Certificate";
    /**
     * The SSO Secret is a SharedKey that is stored in KeyVault.
     */
    readonly SharedKeyInKeyVault: "SharedKeyInKeyVault";
    /**
     * The SSO Secret is a Certificate that is stored in KeyVault.
     */
    readonly CertificateInKeyVault: "CertificateInKeyVault";
};
/**
 * The type of single sign on Secret Type.
 */
export type SSOSecretType = (typeof SSOSecretType)[keyof typeof SSOSecretType];
export declare const ScalingHostPoolType: {
    /**
     * Users get a new (random) SessionHost every time it connects to the HostPool.
     */
    readonly Pooled: "Pooled";
    /**
     * Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
     */
    readonly Personal: "Personal";
};
/**
 * HostPool type for desktop.
 */
export type ScalingHostPoolType = (typeof ScalingHostPoolType)[keyof typeof ScalingHostPoolType];
export declare const SessionHandlingOperation: {
    /**
     * No action will be taken after disconnect
     */
    readonly None: "None";
    /**
     * Session Host will be deallocated after disconnect
     */
    readonly Deallocate: "Deallocate";
    /**
     * Session Host will hibernate after disconnect
     */
    readonly Hibernate: "Hibernate";
};
/**
 * Action to be taken after a logoff during the ramp up period.
 */
export type SessionHandlingOperation = (typeof SessionHandlingOperation)[keyof typeof SessionHandlingOperation];
export declare const SessionHostComponentUpdateType: {
    /**
     * Agent and other agent side components are delivery schedule is controlled by WVD Infra.
     */
    readonly Default: "Default";
    /**
     * TenantAdmin have opted in for Scheduled Component Update feature.
     */
    readonly Scheduled: "Scheduled";
};
/**
 * The type of maintenance for session host components.
 */
export type SessionHostComponentUpdateType = (typeof SessionHostComponentUpdateType)[keyof typeof SessionHostComponentUpdateType];
export declare const SessionHostLoadBalancingAlgorithm: {
    /**
     * Breadth First Algorithm for Load Balancing
     */
    readonly BreadthFirst: "BreadthFirst";
    /**
     * Depth First Algorithm for Load Balancing
     */
    readonly DepthFirst: "DepthFirst";
};
/**
 * Load balancing algorithm for ramp up period.
 */
export type SessionHostLoadBalancingAlgorithm = (typeof SessionHostLoadBalancingAlgorithm)[keyof typeof SessionHostLoadBalancingAlgorithm];
export declare const SetStartVMOnConnect: {
    /**
     * Start VM on Connect is enabled
     */
    readonly Enable: "Enable";
    /**
     * Start VM on Connect is disabled, must use rampUpAutoStartHosts or turn on manually
     */
    readonly Disable: "Disable";
};
/**
 * The desired configuration of Start VM On Connect for the hostpool during the ramp up phase. If this is disabled, session hosts must be turned on using rampUpAutoStartHosts or by turning them on manually.
 */
export type SetStartVMOnConnect = (typeof SetStartVMOnConnect)[keyof typeof SetStartVMOnConnect];
export declare const SkuTier: {
    readonly Free: "Free";
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Premium: "Premium";
};
/**
 * This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
 */
export type SkuTier = (typeof SkuTier)[keyof typeof SkuTier];
export declare const StartupBehavior: {
    /**
     * Session hosts will not be started by the service. This setting depends on Start VM on Connect to be enabled to start the session hosts.
     */
    readonly None: "None";
    /**
     * Session hosts with an assigned user will be started during Ramp Up
     */
    readonly WithAssignedUser: "WithAssignedUser";
    /**
     * All personal session hosts in the hostpool will be started during ramp up.
     */
    readonly All: "All";
};
/**
 * The desired startup behavior during the ramp up period for personal vms in the hostpool.
 */
export type StartupBehavior = (typeof StartupBehavior)[keyof typeof StartupBehavior];
export declare const StopHostsWhen: {
    /**
     * Zero Total Sessions
     */
    readonly ZeroSessions: "ZeroSessions";
    /**
     * Zero Active Sessions
     */
    readonly ZeroActiveSessions: "ZeroActiveSessions";
};
/**
 * Specifies when to stop hosts during ramp down period.
 */
export type StopHostsWhen = (typeof StopHostsWhen)[keyof typeof StopHostsWhen];
